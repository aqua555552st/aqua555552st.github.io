<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>代码块演示、</title>
      <link href="/2024/02/02/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA%E3%80%81/"/>
      <url>/2024/02/02/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA%E3%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="一个测试"><a href="#一个测试" class="headerlink" title="一个测试"></a>一个测试</h1><p>彻底击败了发错了口气</p><p><strong>乘客刷卡发票</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">foreach section s &#123;</span><br><span class="line">foreach relocation entry r &#123;</span><br><span class="line">refptr = s + r.offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*1.重定位PC相对引用*/</span></span><br><span class="line"><span class="keyword">if</span>(r.type == R_X86_64_PC32) &#123;</span><br><span class="line">refaddr = ADDR(s) + r.offset;<span class="comment">/*refaddr:引用的运行时地址*/</span></span><br><span class="line">*refptr = (<span class="type">unsigned</span>) (ADDR(r.symbol) + r.addend - refaddr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.重定位绝对引用*/</span></span><br><span class="line"><span class="keyword">if</span>(r.type == R_X86_64_32) &#123;</span><br><span class="line">*refptr = (<span class="type">unsigned</span>) (ADDR(r.symbol) + r.addend);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动图演示：</strong></p><p><img src="https://typora-lhy-cs.oss-cn-nanjing.aliyuncs.com/180C8691E87430D03D0C84F987C4FA3B.jpg" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>gcc—工具链</title>
      <link href="/2024/02/02/gcc%E2%80%94%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
      <url>/2024/02/02/gcc%E2%80%94%E5%B7%A5%E5%85%B7%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="gcc工具链"><a href="#gcc工具链" class="headerlink" title="gcc工具链"></a>gcc工具链</h1><p><img src="https://typora-lhy-cs.oss-cn-nanjing.aliyuncs.com/image-20240202000746320.png" alt="目录结构"></p><h2 id="一、gcc四步骤"><a href="#一、gcc四步骤" class="headerlink" title="一、gcc四步骤"></a>一、gcc四步骤</h2><p><img src="https://typora-lhy-cs.oss-cn-nanjing.aliyuncs.com/C9577FD85681FA27D4706612B317E577.png" alt="gcc4部操作"></p><h3 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1.预处理"></a>1.预处理</h3><p>预处理器处理C语言源代码，<strong>扫描程序中所有的#开头的预编译指令，并将它们替换成相应的文本</strong>。预编译指令可以包括头文件包含、条件编译等等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure><h3 id="2-编译"><a href="#2-编译" class="headerlink" title="2.编译"></a>2.编译</h3><blockquote><p><strong>消耗时间和系统资源最多</strong></p></blockquote><p>编译器将预处理器处理后的代码<strong>转换成汇编代码</strong>。它会对代码进行语法和语义分析，检查程序的语法错误和类型错误，并生成汇编代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure><h3 id="3-汇编"><a href="#3-汇编" class="headerlink" title="3.汇编"></a>3.汇编</h3><p>汇编器将汇编代码转换成机器码。它会将<strong>汇编代码转换为可执行代码</strong>，同时还会生成调试信息和符号表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure><h3 id="4-链接"><a href="#4-链接" class="headerlink" title="4.链接"></a>4.链接</h3><p>链接器将编译器生成的目标代码以及可能的库文件合并成最终的可执行文件。链接器<strong>将所有代码段和数据段链接起来，解析所有的符号引用，将地址回填。生成可执行文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure><hr><h2 id="二、gcc编译常用参数"><a href="#二、gcc编译常用参数" class="headerlink" title="二、gcc编译常用参数"></a>二、gcc编译常用参数</h2><h3 id="1-头文件跨目录依赖"><a href="#1-头文件跨目录依赖" class="headerlink" title="1.头文件跨目录依赖"></a>1.头文件跨目录依赖</h3><p><strong>源文件与头文件不在同一个目录下</strong></p><img src="https://typora-lhy-cs.oss-cn-nanjing.aliyuncs.com/image-20231228150656571.png" alt="当前目录结构"  /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -I./newdir/ gcctest.c -o gcctest <span class="comment">//-I后面表示头文件所在路径(绝对/相对)</span></span><br></pre></td></tr></table></figure><h3 id="2-只做预处理-编译-汇编"><a href="#2-只做预处理-编译-汇编" class="headerlink" title="2.只做预处理+编译+汇编"></a>2.只做预处理+编译+汇编</h3><p><em><em>得到</em>.o的二进制文件</em>*</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c gcctest -o gcctest.o</span><br></pre></td></tr></table></figure><h3 id="3-编译时添加调试语句"><a href="#3-编译时添加调试语句" class="headerlink" title="3.编译时添加调试语句"></a>3.编译时添加调试语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g gcctest.c -o gcctest2</span><br></pre></td></tr></table></figure><p><strong>显然，编译出来的可执行文件大小变大了，多了可调试文件在内</strong></p><img src="https://typora-lhy-cs.oss-cn-nanjing.aliyuncs.com/image-20231228152301962.png" alt="添加调试语句-文件变大" style="zoom:67%;" /><hr><h2 id="三、csapp—chapter7-链"><a href="#三、csapp—chapter7-链" class="headerlink" title="三、csapp—chapter7:链"></a>三、csapp—chapter7:链</h2><p>已知一个main.c文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="comment">//count和value两个全局变量</span></span><br><span class="line"> <span class="number">3</span> <span class="type">int</span> count = <span class="number">10</span>;</span><br><span class="line"> <span class="number">4</span> <span class="type">int</span> value;</span><br><span class="line"> <span class="number">5</span> </span><br><span class="line"> <span class="number">6</span> <span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> sum)</span> &#123;</span><br><span class="line"> <span class="number">7</span>         <span class="built_in">printf</span>(<span class="string">&quot;sum is:%d\n&quot;</span>, sum);</span><br><span class="line"> <span class="number">8</span> &#125;</span><br><span class="line"> <span class="number">9</span> </span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line"><span class="number">12</span>         <span class="type">static</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="number">13</span>         <span class="type">static</span> <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="number">14</span>         <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="number">15</span> </span><br><span class="line"><span class="number">16</span>         func(a + b + x);</span><br><span class="line"><span class="number">17</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">18</span> &#125;</span><br></pre></td></tr></table></figure><p>通过<code>gcc -c main.c</code>得到可重定位二进制文件，再根据<code>wc -c main.o</code>查看main.o文件的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@lhyEdu01 link]<span class="meta"># gcc -c main.c</span></span><br><span class="line">[root@lhyEdu01 link]<span class="meta"># wc -c main.o</span></span><br><span class="line"><span class="number">1856</span> main.o</span><br></pre></td></tr></table></figure><p>使用<code>readelf -h main.o</code>查看ELF可重定位目标文件的ELF头(ELF Header)的具体内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -h main.o<span class="comment">//-h：只显示ELF Header的信息</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@lhyEdu01 link]<span class="meta"># readelf -h main.o</span></span><br><span class="line">ELF 头：</span><br><span class="line">  Magic：  <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  类别:                              ELF64</span><br><span class="line">  数据:                              <span class="number">2</span> 补码，小端序 (little endian)</span><br><span class="line">  版本:                              <span class="number">1</span> (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI 版本:                          <span class="number">0</span></span><br><span class="line">  类型:                              REL (可重定位文件)</span><br><span class="line">  系统架构:                          Advanced Micro Devices X86<span class="number">-64</span></span><br><span class="line">  版本:                              <span class="number">0x1</span></span><br><span class="line">  入口点地址：              <span class="number">0x0</span></span><br><span class="line">  程序头起点：              <span class="number">0</span> (bytes into file)</span><br><span class="line">  Start of section headers:          <span class="number">1024</span> (bytes into file)</span><br><span class="line">  标志：             <span class="number">0x0</span></span><br><span class="line">  本头的大小：       <span class="number">64</span> (字节)</span><br><span class="line">  程序头大小：       <span class="number">0</span> (字节)</span><br><span class="line">  Number of program headers:         <span class="number">0</span></span><br><span class="line">  节头大小：         <span class="number">64</span> (字节)</span><br><span class="line">  节头数量：         <span class="number">13</span></span><br><span class="line">  字符串表索引节头： <span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="1-可重定位目标文件-ELF文件"><a href="#1-可重定位目标文件-ELF文件" class="headerlink" title="1.可重定位目标文件(ELF文件)"></a>1.可重定位目标文件(ELF文件)</h3><p><img src="https://typora-lhy-cs.oss-cn-nanjing.aliyuncs.com/image-20231228190228140.png" alt="ELF文件"></p><h3 id="2-section-节-的具体内容"><a href="#2-section-节-的具体内容" class="headerlink" title="2.section(节)的具体内容"></a>2.section(节)的具体内容</h3><ol><li><strong><code>.text</code>：已编译程序的及其代码</strong></li><li><strong><code>.rodata</code>：只读数据，如：prinf函数内的格式串</strong></li><li><strong><code>.data</code>：<u>已初始化</u>的全局和静态C变量</strong></li><li><strong><code>.bss(Better Save Space)</code>：<u>未初始化</u>的全局和静态C变量</strong></li><li><img src="https://typora-lhy-cs.oss-cn-nanjing.aliyuncs.com/image-20231228191717559.png" style="zoom: 33%;" /></li></ol><h3 id="3-符号-符号表-symtab）"><a href="#3-符号-符号表-symtab）" class="headerlink" title="3.符号&amp;符号表(.symtab）"></a>3.符号&amp;符号表(.symtab）</h3><p><strong>对于每一个可重定位目标文件(ELF)m，都有一个符号表(.symtab节中)。在链接器的上下文中，有三种不同的符号：</strong></p><ol><li><strong><code>全局符号(Global Symbols)</code>：模块m定义+能被其他模块引用</strong></li><li><strong><code>外部符号(Externals Symbols)</code>：其他模块定义+能被模块m引用</strong></li><li><strong><code>局部符号(Local Symbols)</code>：只被模块m定义+其他模块不能引用。如：任何带有static修饰的全局变量或函数 都是模块私有的，其他模块不能访问，类似Java的private关键字</strong></li></ol><blockquote><p><strong>注：</strong>.symtab节的符号表不包含<strong>本地非静态局部变量</strong>，因为其在<strong>栈中被管理</strong>！</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@lhyEdu01 link]<span class="meta"># readelf -s main.o</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">16</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS main.c</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">1</span> </span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">3</span> </span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">4</span> </span><br><span class="line">     <span class="number">5</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">5</span> </span><br><span class="line">     <span class="number">6</span>: <span class="number">0000000000000004</span>     <span class="number">4</span> OBJECT  LOCAL  DEFAULT    <span class="number">3</span> a<span class="number">.2185</span></span><br><span class="line">     <span class="number">7</span>: <span class="number">0000000000000000</span>     <span class="number">4</span> OBJECT  LOCAL  DEFAULT    <span class="number">4</span> b<span class="number">.2186</span></span><br><span class="line">     <span class="number">8</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">7</span> </span><br><span class="line">     <span class="number">9</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">8</span> </span><br><span class="line">    <span class="number">10</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">6</span> </span><br><span class="line">    <span class="number">11</span>: <span class="number">0000000000000000</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT    <span class="number">3</span> count</span><br><span class="line">    <span class="number">12</span>: <span class="number">0000000000000004</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT  COM value</span><br><span class="line">    <span class="number">13</span>: <span class="number">0000000000000000</span>    <span class="number">33</span> FUNC    GLOBAL DEFAULT    <span class="number">1</span> func</span><br><span class="line">    <span class="number">14</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND <span class="built_in">printf</span></span><br><span class="line">    <span class="number">15</span>: <span class="number">0000000000000021</span>    <span class="number">55</span> FUNC    GLOBAL DEFAULT    <span class="number">1</span> main</span><br></pre></td></tr></table></figure><blockquote><p>Type：FUNC-函数、OBJECT-变量数组等数据对象</p><p>Value：表示函数相对于.text section起始位置的偏移量</p><p>Bind：作用范围。局部&#x2F;全局</p><p>Ndx：表示节头部表的section的数组索引。如：Ndx&#x3D;1表示在.text节；Ndx&#x3D;3表示在.data节</p><blockquote><p>Ndx表示中有<strong>3个伪节：</strong></p></blockquote><blockquote><ul><li><strong><code>ABS</code>：不该被重定位的符号</strong></li><li><strong><code>UNDEF</code>：未定义的符号</strong></li><li><strong><code>COMMON</code>：未被分配位置的初始化的数据目标</strong></li></ul></blockquote><blockquote><p><strong>注意：变量count和value属于不同section的原因：count初始化了，value没有初始化</strong></p></blockquote><blockquote><p><strong>COMMON：未初始化的全局变量；.bss节：未初始化的静态变量+初始化为0的静态&#x2F;全局变量</strong></p></blockquote></blockquote><h3 id="4-符号解析"><a href="#4-符号解析" class="headerlink" title="4.符号解析"></a>4.符号解析</h3><p>对以下源文件进行编译linkerror.c进行编译汇编，生成二进制文件linkerror.o。</p><p>其中，该代码<strong>仅对函数foo进行声明</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        foo();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -c linkerror.c </code>，编译可以通过！<font size=3 color=red>当编译器遇到一个不是在当前模块定义的符号(变量&#x2F;函数名)时，会假设该符号是在在其他模块在定义的。</font></p><p><font size=3 color=red>但是链接器(ld)无法解析对foo的引用时，就会终止！</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@lhyEdu01 link]<span class="meta"># gcc -Wall -Og -o linkerror linkerror.c</span></span><br><span class="line">/tmp/cc5EcYAf.o：在函数‘main’中：</span><br><span class="line">linkerror.c:(.text+<span class="number">0x5</span>)：对‘foo’未定义的引用</span><br><span class="line">collect2: 错误：ld 返回 <span class="number">1</span></span><br></pre></td></tr></table></figure><p><font size=4 color=red>引出问题：”全局符号”在多个可重定位目标文件中【同名定义】，如何处理？</font></p><p><strong>编译时，编译器向汇编器输出每个全局符号的类型：</strong></p><ul><li><strong><code>Strong symbols(强符号)</code>：函数和已初始化的全局变量</strong></li><li><strong><code>Weak symbols(弱符号)</code>：未初始化的全局变量</strong></li></ul><p><strong>汇编时，汇编器将强弱信息隐含地编码在ELF的符号表(.symtab)里</strong></p><p><strong>链接时，链接器根据以下3种情况处理多重定义的全局符号：</strong></p><ol><li><p><strong>规则1：不允许有多个同名的强符号</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*foo1.c*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*bar1.c*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@lhyEdu01 link]<span class="meta"># gcc foo1.c bar1.c</span></span><br><span class="line">/tmp/ccSHeCo9.o：在函数‘main’中：</span><br><span class="line">bar1.c:(.text+<span class="number">0x0</span>): main 的多重定义</span><br><span class="line">/tmp/ccnLYE7L.o:foo1.c:(.text+<span class="number">0x0</span>)：第一次在此定义</span><br><span class="line">collect2: 错误：ld 返回 <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p><strong>规则2：一个强符号与多个弱符号同名，那么选择强符号</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*foo2.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">15213</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        f();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>, x);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*bar2.c*/</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        x = <span class="number">15212</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@lhyEdu01 link]<span class="meta"># gcc foo2.c bar2.c</span></span><br><span class="line">[root@lhyEdu01 link]# ./a.out</span><br><span class="line">x = <span class="number">15212</span></span><br></pre></td></tr></table></figure><p>函数f将x的值由15213改为15212。一个模块(bar2.c)里的x未初始化(弱符号)，链接器会安静地选择其他模块(foo2.c)里定义的强符号</p></li><li><p><strong>规则3：如果有多个弱符号同名，任意选择一个</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*foo3.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> y = <span class="number">15212</span>;</span><br><span class="line"><span class="type">int</span> x = <span class="number">15213</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        f();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x = 0x%x y = 0x%x\n&quot;</span>, x, y);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*bar3.c*/</span></span><br><span class="line"><span class="type">double</span> x;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        x = <span class="number">-0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@lhyEdu01 link]<span class="meta"># gcc foo3.c bar3.c</span></span><br><span class="line">/usr/bin/ld: Warning: alignment <span class="number">4</span> of symbol `x<span class="number">&#x27;</span> in /tmp/ccWPcPGG.o is smaller than <span class="number">8</span> in /tmp/cc3MhEaU.o</span><br></pre></td></tr></table></figure></li></ol><h4 id="静态库-static-library"><a href="#静态库-static-library" class="headerlink" title="静态库(static library)"></a>静态库(static library)</h4><p>在共享库出现之前，<strong>公用功能(atoi&#x2F;printf&#x2F;scanf&#x2F;strcpy&#x2F;rand等)<strong>是以</strong>静态库</strong>的形式存在的，它把<strong>通用功能模块的多个目标文件打包在一起形成<code>*.a</code>的文件(如libc.a)<strong>，用到它的程序只需要在链接时指定这个库文件，</strong>链接器就会从这个库中抽取出用到的功能代码拷贝到目标程序中</strong>，而不需要每次都对这些通用功能代码重新编译。</p><p><strong>对文件<em>addvec.c</em>和<em>multvec.c</em>进行编译<code>gcc -c addvec.c multvec.c</code>，得到目标模块</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> addcnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">addvec</span><span class="params">(<span class="type">int</span> * x, <span class="type">int</span> * y, <span class="type">int</span> * z, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        </span><br><span class="line">        addcnt++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                z[i] = x[i] + y[i];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> multcnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">multvec</span><span class="params">(<span class="type">int</span> * x, <span class="type">int</span> * y, <span class="type">int</span> * z, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        </span><br><span class="line">        multcnt++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                z[i] = x[i] * y[i];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用<code>AR工具</code>将两个目标模块<em>addvec.o multvec.o</em>打包成静态库(<code>ar rcs libxxx.a xxx.o xxx.o</code>)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lhyEdu01 link]<span class="meta"># ar rcs linvector.a addvec.o multvec.o</span></span><br></pre></td></tr></table></figure><p>以main2.c文件为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vector.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> z[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        addvec(x, y, z, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;z = [%d %d]\n&quot;</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中”vector.h”中包含对addvec函数的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">addvec</span><span class="params">(<span class="type">int</span> * x, <span class="type">int</span> * y, <span class="type">int</span> * z, <span class="type">int</span> n)</span>;</span><br></pre></td></tr></table></figure><p><strong>编译和链接输入文件main2.o和libvector.a</strong></p><img src="https://typora-lhy-cs.oss-cn-nanjing.aliyuncs.com/1125E426BCF8DCF854B292C45FC50D8A.jpg" style="zoom:20%;" /><blockquote><p><strong>链接器判断main2.o引用了addvec.o定义的addvec符号，所以复制addvec.o到可执行文件。</strong></p><p><strong>因为程序未引用multvec.0定义的符号，所以链接器就不会复制这个模块到可执行文件。</strong></p><p><strong>此外，链接器还会复制libc.a中的printf.o等C系统运行时的其他模块。</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@lhyEdu01 link]<span class="meta"># gcc -c main2.c</span></span><br><span class="line">[root@lhyEdu01 link]<span class="meta"># gcc -static -o prog2c main2.o ./libvector.a</span></span><br><span class="line">[root@lhyEdu01 link]# ./prog2c </span><br><span class="line">z = [<span class="number">4</span> <span class="number">6</span>]</span><br></pre></td></tr></table></figure><h3 id="5-重定位"><a href="#5-重定位" class="headerlink" title="5.重定位"></a>5.重定位</h3><p>当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。也不知道本模块引用的外部定义函数或全局变量的最终位置。</p><p><strong><font size=3 color=red>因此，汇编器遇到对最终位置未知的目标引用，就会生成一个【重定位条目】，告诉链接器再将目标文件合并为可执行文件时如何修改这个引用。</font></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*重定位条目-数据结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">long</span> offset;<span class="comment">//被修改的引用的节偏移量</span></span><br><span class="line"><span class="type">long</span> type:<span class="number">32</span>,<span class="comment">//告知链接器如何修改新的引用</span></span><br><span class="line">    <span class="comment">//主要两种：1.R_X86_64_PC32(PC相对地址)2.R_X86_64_32(绝对地址)</span></span><br><span class="line">symbol:<span class="number">32</span>;<span class="comment">//表示被修改的引用是哪个符号</span></span><br><span class="line"><span class="type">long</span> addend;<span class="comment">//有符号数，一些类型的重定位要使用它对被修改引用的值做偏移调整(指令长度)</span></span><br><span class="line">&#125; ELF_Rela</span><br></pre></td></tr></table></figure><blockquote><p><strong>代码的重定位条目存放在<code>.rel.text</code>中</strong></p><p><strong>已初始化数据的重定位条目存放在<code>.rel.data</code>中</strong></p></blockquote><h4 id="重定位算法"><a href="#重定位算法" class="headerlink" title="重定位算法"></a>重定位算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">foreach section s &#123;</span><br><span class="line">foreach relocation entry r &#123;</span><br><span class="line">refptr = s + r.offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*1.重定位PC相对引用*/</span></span><br><span class="line"><span class="keyword">if</span>(r.type == R_X86_64_PC32) &#123;</span><br><span class="line">refaddr = ADDR(s) + r.offset;<span class="comment">/*refaddr:引用的运行时地址*/</span></span><br><span class="line">*refptr = (<span class="type">unsigned</span>) (ADDR(r.symbol) + r.addend - refaddr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.重定位绝对引用*/</span></span><br><span class="line"><span class="keyword">if</span>(r.type == R_X86_64_32) &#123;</span><br><span class="line">*refptr = (<span class="type">unsigned</span>) (ADDR(r.symbol) + r.addend);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="①重定位PC相对引用"><a href="#①重定位PC相对引用" class="headerlink" title="①重定位PC相对引用"></a>①重定位PC相对引用</h4><p><strong>例：对源文件<em>main.c</em>和<em>sum.c</em>进行反汇编：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> * a, <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> val = sum(<span class="built_in">array</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> * a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i, s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                s += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>再用<code>objdump -dx main.o</code>对main,o进行反编译后结果：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lhyEdu01 link]<span class="meta"># objdump -dx main.o</span></span><br></pre></td></tr></table></figure><img src="https://typora-lhy-cs.oss-cn-nanjing.aliyuncs.com/image-20231229213448474.png" style="zoom: 50%;" /><p><strong>函数main调用sum函数，sum函数是在sum.o模块中定义的，sum的重定位条目为：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r,offset = <span class="number">0xf</span></span><br><span class="line">r.symbol = sum</span><br><span class="line">r.type   = R_X86_64_PC32</span><br><span class="line">r.addend = <span class="number">-4</span></span><br></pre></td></tr></table></figure><p><strong><u>这些字段告诉链接器修改开始于0xf处的32位PC相对引用，这样在运行时它会指向sum例程</u>。假设链接器已确定：</strong></p><ul><li><strong><code>ADDR(s) = ADDR(.text)</code> &#x3D; 0x400d0</strong></li><li><strong><code>ADDR(r.symbol) = ADDR(sum)</code> &#x3D; 0x400e8</strong></li></ul><p><strong>使用<code>重定位算法</code>知：</strong></p><ol><li><p><strong>链接器首先算出引用的<u>运行时地址</u>：</strong></p><p><strong>ref_addr &#x3D; ADDR(s) + r.offset &#x3D; 0x4004d0 + 0xf &#x3D; 0x4004df</strong> </p></li><li><p><strong>然后更新该引用，使得它再运行时指向sum程序(实际就是求PC的offset)</strong></p><p><strong>ref_ptr &#x3D; ADDR(sum) - ref_addr + r.addend &#x3D; 0x4004e8 - 0x4004df +(-4) &#x3D; 0x5</strong></p></li></ol><p>得到的可执行文件中，call指令由如下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4004</span>de:e8 <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       callq  <span class="number">4004e8</span> &lt;sum&gt;</span><br></pre></td></tr></table></figure><h4 id="②重定位绝对引用"><a href="#②重定位绝对引用" class="headerlink" title="②重定位绝对引用"></a>②重定位绝对引用</h4><p><strong>mov指令将array地址(32位立即数)复制到寄存器%edi中，sum函数是在sum.o模块中定义的，sum的重定位条目为：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r,offset = <span class="number">0xa</span></span><br><span class="line">r.symbol = <span class="built_in">array</span></span><br><span class="line">r.type   = R_X86_64_32</span><br><span class="line">r.addend = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>这些字段告诉链接器修改开始于0xa处的32位绝对引用，这样在运行时它会指向array的第一个字节。假设链接器已确定：</p><ul><li><strong><code>ADDR(r.symbol) = ADDR(array)</code> &#x3D; 0x601018</strong></li></ul><p>链接器修改第13行的引用：</p><p>*<strong>ref_ptr &#x3D; (unsigned) ((ADDR(r.symbol) + r.addend)) &#x3D; (unsigned) (0x601018 + 0) &#x3D; 0x601018</strong></p><p>得到的可执行文件中，机器指令由如下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4004</span>d9:bf <span class="number">18</span> <span class="number">10</span> <span class="number">60</span> <span class="number">00</span>       mov $<span class="number">0x601018</span>, %edi</span><br></pre></td></tr></table></figure><p><img src="https://typora-lhy-cs.oss-cn-nanjing.aliyuncs.com/D0D016AAD0F392AC3C3FFCEFEFAA42CC.jpg"></p><h3 id="6-可执行目标文件-加载过程"><a href="#6-可执行目标文件-加载过程" class="headerlink" title="6.可执行目标文件&amp;加载过程"></a>6.可执行目标文件&amp;加载过程</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="/2024/01/31/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/01/31/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/01/31/hello-world/"/>
      <url>/2024/01/31/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
